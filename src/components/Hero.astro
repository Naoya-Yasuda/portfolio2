---
---

<section id="top" class="top-wrapper">
  <div class="top_images">
    <div class="hero-media responsive_pc">
      <img src="/portfolio2/img/bgimage.jpeg" alt="Yasuda's portfolio website's top image" class="hero-img">
      <video src="/portfolio2/img/hero.mp4" muted loop playsinline class="hero-video"></video>
    </div>
    <img src="/portfolio2/img/bgimage_responsive.jpeg" alt="Yasuda's portfolio website's top image to responsive" class="responsive_notpc">
  </div>

  <div id="main-title">
    <h1>Naoya YASUDA's <br class="responsive_notpc">Portfolios <span class="responsive_notpc">Site</span></h1>
  </div>

  <div class="neural-network-wrapper">
    <canvas id="neuralCanvas" class="neural-canvas"></canvas>
  </div>
</section>

<script>
  const canvas = document.getElementById('neuralCanvas') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d');

  interface Node {
    x: number;
    y: number;
    vx: number;
    vy: number;
  }

  const nodes: Node[] = [];
  // 画面幅に応じてノード数を調整（スマホは少なく）
  const getNodeCount = () => window.innerWidth < 768 ? 20 : 50;
  let nodeCount = getNodeCount();

  function resizeCanvas() {
    const wrapper = canvas.parentElement;
    if (wrapper) {
      canvas.width = wrapper.offsetWidth;
      canvas.height = wrapper.offsetHeight;
    }
  }

  function initNodes() {
    nodes.length = 0;
    for (let i = 0; i < nodeCount; i++) {
      nodes.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
      });
    }
  }

  function animate() {
    if (!ctx) return;

    // トレイル効果（残像）- 既存の描画を少し透明にする（背景は透明のまま）
    ctx.globalCompositeOperation = 'destination-out';
    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.globalCompositeOperation = 'source-over';

    nodes.forEach((node, i) => {
      node.x += node.vx;
      node.y += node.vy;

      if (node.x < 0 || node.x > canvas.width) node.vx *= -1;
      if (node.y < 0 || node.y > canvas.height) node.vy *= -1;

      nodes.forEach((otherNode, j) => {
        if (i === j) return;

        const dx = node.x - otherNode.x;
        const dy = node.y - otherNode.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < 150) {
          ctx.beginPath();
          ctx.strokeStyle = `rgba(220, 235, 230, ${1 - distance / 150})`;
          ctx.lineWidth = 0.5;
          ctx.moveTo(node.x, node.y);
          ctx.lineTo(otherNode.x, otherNode.y);
          ctx.stroke();
        }
      });

      ctx.beginPath();
      ctx.fillStyle = '#dcebe6';
      ctx.arc(node.x, node.y, 2, 0, Math.PI * 2);
      ctx.fill();
    });

    requestAnimationFrame(animate);
  }

  resizeCanvas();
  initNodes();
  animate();
  window.addEventListener('resize', () => {
    resizeCanvas();
    nodeCount = getNodeCount();
    initNodes();
  });

  // Hero video hover control
  const heroMedia = document.querySelector('.hero-media');
  const heroVideo = document.querySelector('.hero-video') as HTMLVideoElement;

  if (heroMedia && heroVideo) {
    const heroImg = document.querySelector('.hero-img') as HTMLImageElement;
    let hasPlayed = false;
    let videoReady = false;

    // 動画の読み込み完了を待つ
    heroVideo.addEventListener('canplaythrough', () => {
      videoReady = true;
    });

    // 既に読み込み済みの場合
    if (heroVideo.readyState >= 4) {
      videoReady = true;
    }

    heroMedia.addEventListener('mouseenter', () => {
      if (!videoReady) return; // 動画が読み込まれるまでホバー無効

      if (!hasPlayed) {
        // 初回ホバー時に画像を非表示にして動画を表示
        heroImg.style.opacity = '0';
        heroVideo.style.opacity = '0.85';
        hasPlayed = true;
      }
      heroVideo.play();
    });

    heroMedia.addEventListener('mouseleave', () => {
      heroVideo.pause();
      // 動画は表示したまま（画像に戻さない）
    });
  }
</script>

<style>
  .top-wrapper {
    text-align: center;
    position: relative;
    overflow: hidden;
  }

  .top_images img {
    width: 100%;
    height: auto;
    opacity: 0.85;
    vertical-align: bottom;
  }

  .hero-media {
    position: relative;
    width: 100%;
  }

  .hero-media .hero-img {
    width: 100%;
    height: auto;
    display: block;
    transition: opacity 0.3s ease;
  }

  .hero-media .hero-video {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    opacity: 0;
    transition: opacity 0.3s ease;
  }


  #main-title {
    border-bottom: solid 2px #fff;
    width: 100%;
    position: absolute;
    top: 50%;
    transform: translate(0, -50%);
    pointer-events: none;
  }

  #main-title h1 {
    font-size: 50px;
    margin: 0;
    color: #fff;
  }

  .responsive_notpc {
    display: none;
  }

  .top_images .responsive_notpc {
    display: none;
  }

  .neural-network-wrapper {
    position: absolute;
    top: 10%;
    left: 5%;
    width: 90%;
    height: 80%;
    pointer-events: none;
    z-index: 2;
  }

  .neural-canvas {
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .neural-network-wrapper {
      display: none;
    }

    .top-wrapper {
      margin-top: 0;
    }

    #main-title h1 {
      font-size: 30px;
    }

    .top_images .responsive_pc {
      display: none;
    }

    .top_images .responsive_notpc {
      display: inline;
    }

    .responsive_notpc {
      display: inline;
    }
  }
</style>
